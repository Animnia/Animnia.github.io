<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>HE Rank</title>
  <style>
    :root {
      --header-h: 64px;
      --gap: 8px;
      --piece-size: 96px; /* 固定像素，确保移动端与PC视觉一致 */
      --thumb-size: var(--piece-size); /* 托盘缩略图尺寸，默认与拼块一致 */
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }
    body { user-select: none; background: #fff; }

    .header {
      position: fixed;
      left: 0;
      top: 0;
      width: 75vw;
      height: var(--header-h);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: 800;
      color: #1f1f1f;
      text-shadow: 0 2px 6px rgba(0,0,0,0.15);
      pointer-events: none;
      z-index: 1000;
    }

    .canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .board {
      position: fixed;
      top: var(--header-h);
      left: 0;
      width: 75vw;
      height: calc(100vh - var(--header-h));
      z-index: 0;
      background-color: #f7f7f7;
      background-image: url('./images/board.png');
      background-repeat: no-repeat;
      background-position: left center;
      background-size: contain;
    }

    .right-zone {
      position: fixed;
      top: 0;
      left: 75vw;
      width: 25vw;
      height: 100vh;
      z-index: 1;
      background: transparent;
    }

    .tray {
      position: absolute;
      inset: 0;
      overflow: auto;
      padding: var(--gap);
      background: linear-gradient(180deg, rgba(0,0,0,0.03), rgba(0,0,0,0.015));
      backdrop-filter: blur(2px);
      -webkit-overflow-scrolling: touch; /* 移动端惯性滚动 */
    }
    .tray-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(var(--thumb-size), 1fr));
      grid-auto-rows: var(--thumb-size);
      gap: var(--gap);
      align-content: start;
    }
    .thumb {
      width: 100%;
      height: 100%;
      object-fit: contain;
      cursor: grab;
      user-select: none;
      -webkit-user-drag: none;
      background: #fff;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }

    .pieces-layer {
      position: absolute;
      inset: 0;
      z-index: 10; 
      pointer-events: none;
    }

    .piece {
      position: absolute;
      width: var(--piece-size);
      height: var(--piece-size);
      object-fit: contain;
      cursor: grab;
      touch-action: none; /* 阻止手势滚动，便于拖动 */
      user-select: none;
      -webkit-user-drag: none;
      transition: box-shadow .1s ease;
      pointer-events: auto; 
    }
    .piece:active {
      cursor: grabbing;
      box-shadow: 0 4px 12px rgba(0,0,0,.25);
    }

    /* 移动端（触摸设备）上，适度放大左侧背景图（横屏/宽屏布局时） */
    @media (hover: none) and (pointer: coarse) {
      body.landscape .board {
        background-size: 120% auto;
        background-position: left center;
      }
    }

    /* 纵向（高 > 宽）布局：标题顶端居中；上半区为背景板，下半区为图片托盘 */
    body.portrait .header {
      width: 100vw;
      left: 0;
      top: 0;
      height: var(--header-h);
      justify-content: center;
    }
    body.portrait .board {
      top: var(--header-h);
      left: 0;
      width: 100vw;
      height: calc(50vh - var(--header-h));
      background-position: center center;
      background-size: contain;
    }
    body.portrait .right-zone {
      top: 50vh;
      left: 0;
      width: 100vw;
      height: 50vh;
    }

    /* 当页面宽度小于 512px 时：
       - 标题字号缩小为原来的 1/2
       - 托盘缩略图宽高缩小为原来的 1/2（固定尺寸，不拉伸） */
    @media (max-width: 512px) {
      .header { font-size: 16px; }
      :root { --thumb-size: calc(var(--piece-size) / 2); }
      .tray-grid {
        grid-template-columns: repeat(auto-fill, var(--thumb-size));
        grid-auto-rows: var(--thumb-size);
      }
    }
  </style>
</head>
<body>
  <div class="header">《吹响吧！上低音号》角色实力排行</div>

  <div class="canvas" id="canvas">
    <div class="board" aria-hidden="true"></div>
    <div class="right-zone" aria-label="图片托盘">
      <div class="tray">
        <div class="tray-grid" id="trayGrid" aria-label="可拖拽图片列表"></div>
      </div>
    </div>
    <div class="pieces-layer" id="piecesLayer" aria-label="可拖拽图片层"></div>
  </div>

  <script>
    const pieceFiles = [
      '川岛绿辉.png',
      '釜屋燕.png',
      '高坂丽奈.png',
      '高久智惠理.png',
      '黑江真由.png',
      '后藤卓也.png',
      '黄前久美子.png',
      '吉川优子.png',
      '加藤叶月.png',
      '剑崎梨梨花.png',
      '堺万纱子.png',
      '井上顺菜.png',
      '久石奏.png',
      '铠冢霙.png',
      '伞木希美.png',
      '田中明日香.png',
      '小笠原晴香.png',
      '月永求.png',
      '斋藤葵.png',
      '长濑梨子.png',
      '中川夏纪.png',
      '中世古香织.png',
      '冢本秀一.png',
    ];

  const canvas = document.getElementById('canvas');
  const layer = document.getElementById('piecesLayer');
  const trayGrid = document.getElementById('trayGrid');
  let zTop = 1;
  const usedPieces = new Set(); // 已生成的拼块名集合，确保只生成一次

    function getDisplayName(fileName) {
      return fileName.replace(/\.[^/.]+$/,'');
    }

    function initTray() {
      trayGrid.innerHTML = '';
      pieceFiles.forEach((name) => {
        const thumb = document.createElement('img');
        thumb.className = 'thumb';
        const label = getDisplayName(name);
        thumb.alt = label;
        thumb.title = label; 
        thumb.setAttribute('aria-label', label);
        thumb.src = `./images/${name}`;
        thumb.draggable = false;

        const spawnOnce = (clientX, clientY) => {
          if (usedPieces.has(name)) return;
          usedPieces.add(name);
          const piece = createFloatingPiece(name, clientX, clientY);
          startDragWithPointer(piece, clientX, clientY);
          thumb.alt = '';
          thumb.src = `./images/empty.png`;
          thumb.style.cursor = 'default';
        };

        thumb.addEventListener('mousedown', (e) => {
          if (e.button !== 0) return;
          e.preventDefault();
          spawnOnce(e.clientX, e.clientY);
        });
        thumb.addEventListener('touchstart', (e) => {
          const t = e.touches[0];
          spawnOnce(t.clientX, t.clientY);
        }, { passive: true });

        trayGrid.appendChild(thumb);
      });
    }

    function createFloatingPiece(name, clientX, clientY) {
      const img = document.createElement('img');
      img.className = 'piece';
      const label = getDisplayName(name);
      img.alt = label;
      img.title = label;
      img.setAttribute('aria-label', label);
      img.src = `./images/${name}`;
      img.draggable = false;
      img.style.zIndex = (++zTop).toString();

      const layerRect = layer.getBoundingClientRect();
      const size = getPiecePixelSize();
      const x = clientX - layerRect.left - size / 2;
      const y = clientY - layerRect.top - size / 2;
      img.style.left = `${x}px`;
      img.style.top = `${y}px`;

      layer.appendChild(img);
      makeDraggable(img);
      return img;
    }

    function getPiecePixelSize() {
      const tmp = document.createElement('div');
      tmp.style.position = 'absolute';
      tmp.style.visibility = 'hidden';
      tmp.style.width = getComputedStyle(document.documentElement).getPropertyValue('--piece-size');
      document.body.appendChild(tmp);
      const size = tmp.getBoundingClientRect().width;
      tmp.remove();
      return size || 80;
    }

    function clamp(v, min, max) { return Math.min(Math.max(v, min), max); }

    function makeDraggable(el) {
      let dragging = false;
      let offsetX = 0, offsetY = 0;
      const onDown = (clientX, clientY) => {
        dragging = true;
        const layerRect = layer.getBoundingClientRect();
        const left = parseFloat(el.style.left || '0');
        const top = parseFloat(el.style.top || '0');
        offsetX = clientX - (layerRect.left + left);
        offsetY = clientY - (layerRect.top + top);
        el.style.zIndex = (++zTop).toString();
      };

      const onMove = (clientX, clientY) => {
        if (!dragging) return;
        const layerRect = layer.getBoundingClientRect();
        const pieceSize = el.getBoundingClientRect().width;
        let x = clientX - layerRect.left - offsetX;
        let y = clientY - layerRect.top - offsetY;
        x = clamp(x, -pieceSize * 0.5, layerRect.width - pieceSize * 0.5);
        y = clamp(y, -pieceSize * 0.5, layerRect.height - pieceSize * 0.5);
        el.style.left = `${x}px`;
        el.style.top = `${y}px`;
      };

      const onUp = () => { dragging = false; };

      el.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        e.preventDefault();
        onDown(e.clientX, e.clientY);
        const move = (ev) => onMove(ev.clientX, ev.clientY);
        const up = () => {
          onUp();
          document.removeEventListener('mousemove', move);
          document.removeEventListener('mouseup', up);
        };
        document.addEventListener('mousemove', move);
        document.addEventListener('mouseup', up);
      });

      el.addEventListener('touchstart', (e) => {
        const t = e.touches[0];
        onDown(t.clientX, t.clientY);
      }, { passive: true });
      el.addEventListener('touchmove', (e) => {
        const t = e.touches[0];
        onMove(t.clientX, t.clientY);
      }, { passive: true });
      el.addEventListener('touchend', onUp);
      el.addEventListener('touchcancel', onUp);
    }

    function startDragWithPointer(el, clientX, clientY) {
      let dragging = true;
      const layerRect = layer.getBoundingClientRect();
      const left = parseFloat(el.style.left || '0');
      const top = parseFloat(el.style.top || '0');
      let offsetX = clientX - (layerRect.left + left);
      let offsetY = clientY - (layerRect.top + top);
      el.style.zIndex = (++zTop).toString();

      const move = (ev) => {
        if (!dragging) return;
        const e = ev.touches ? ev.touches[0] : ev;
        const pieceSize = el.getBoundingClientRect().width;
        let x = e.clientX - layerRect.left - offsetX;
        let y = e.clientY - layerRect.top - offsetY;
        x = clamp(x, -pieceSize * 0.5, layerRect.width - pieceSize * 0.5);
        y = clamp(y, -pieceSize * 0.5, layerRect.height - pieceSize * 0.5);
        el.style.left = `${x}px`;
        el.style.top = `${y}px`;
      };
      const up = () => {
        dragging = false;
        document.removeEventListener('mousemove', move);
        document.removeEventListener('mouseup', up);
        document.removeEventListener('touchmove', move);
        document.removeEventListener('touchend', up);
        document.removeEventListener('touchcancel', up);
      };
      document.addEventListener('mousemove', move);
      document.addEventListener('mouseup', up);
      document.addEventListener('touchmove', move, { passive: true });
      document.addEventListener('touchend', up);
      document.addEventListener('touchcancel', up);
    }

    // 根据窗口宽高设置布局模式
    function applyLayout() {
      // 在移动端（触摸/无悬停）上，始终使用纵向布局；桌面端按宽高决定
      const isMobile = window.matchMedia('(pointer: coarse)').matches || window.matchMedia('(hover: none)').matches;
      const isPortrait = isMobile ? true : (window.innerHeight > window.innerWidth);
      document.body.classList.toggle('portrait', isPortrait);
      document.body.classList.toggle('landscape', !isPortrait);
    }

    window.addEventListener('resize', applyLayout);
    window.addEventListener('orientationchange', applyLayout);

    window.addEventListener('load', () => {
      applyLayout();
      initTray();
    });
  </script>
</body>
</html>